{"version":3,"sources":["webpack://fast_paced_networking_demo/./src/style.scss","webpack://fast_paced_networking_demo/./src/style.scss?75ba","webpack://fast_paced_networking_demo/./src/math.ts","webpack://fast_paced_networking_demo/./src/index.ts"],"names":["___CSS_LOADER_EXPORT___","push","module","id","api","content","__esModule","default","exports","locals","lerp","a","b","alpha","app","server","tick","tickDuration","tickAccumulator","game","entities","client","net","sim","latency","jitter","packetLoss","inFlightMessages","lastReceivedTick","backBuffer","interpolationDelay","prevNetState","nextNetState","serverTick","dt","forEach","entity","Math","random","angularVelocity","angle","velocity","x","cos","speed","y","sin","position","abs","atan2","PI","window","lastFrameTime","addEventListener","i","j","htmlElement","initAppState","elPane","document","createElement","className","k","elEntity","color","style","backgroundColor","append","getElementById","domCreateElements","requestAnimationFrame","animationFrame","t","rdt","message","ticked","entityPositions","map","e","inFlightMessage","cloneDeep","timeRemaining","filter","onReceiveServerMessage","length","mostRecent","targetSubTick","nextNetStateIdx","findIndex","splice","p","n","idx","prevPosition","nextPosition","interpolatedPosition","entityData","parentWidth","parentElement","clientWidth","parentHeight","clientHeight","transform","frameStep"],"mappings":"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","file":"main.37104407c8c6b74a53aa.js","sourcesContent":["// Imports\nimport ___CSS_LOADER_API_IMPORT___ from \"../node_modules/css-loader/dist/runtime/api.js\";\nvar ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(true);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \"input:focus{outline:none}html{-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;-moz-box-sizing:inherit;box-sizing:inherit}body{margin:0;padding:0;color:#000;width:100%;height:100%;overflow:hidden;font-family:-apple-system,BlinkMacSystemFont,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\",\\\"Segoe UI Symbol\\\"}#root{position:absolute;width:100%;height:100%;background:#141414;gap:4px;display:grid;place-items:center}.pane{background-color:#fff;overflow:hidden;border-radius:4px;position:relative;width:640px;height:480px}.pane .label{position:absolute;width:100%;background-color:rgba(221,221,221,.801);padding:8px}.pane .entity{position:absolute;top:0;left:0;width:20px;height:20px;border-radius:10px;background-color:#000;transform-box:content-box}.pane .entity.ghost{opacity:.3}\", \"\",{\"version\":3,\"sources\":[\"webpack://src/style.scss\"],\"names\":[],\"mappings\":\"AAWI,YACI,YAAA,CAKR,KACI,6BAAA,CACA,0BAAA,CACA,qBAAA,CAGJ,mBACI,0BAAA,CACA,uBAAA,CACA,kBAAA,CAGJ,KACI,QAAA,CACA,SAAA,CACA,UAAA,CAEA,UAAA,CACA,WAAA,CAEA,eAAA,CAEA,gJAAA,CAGJ,MACI,iBAAA,CACA,UAAA,CACA,WAAA,CAEA,kBAAA,CAEA,OAAA,CAEA,YAAA,CACA,kBAAA,CAGJ,MACI,qBAAA,CACA,eAAA,CAEA,iBAAA,CACA,iBAAA,CACA,WAAA,CACA,YAAA,CAEA,aACI,iBAAA,CACA,UAAA,CACA,uCAAA,CACA,WAAA,CAGJ,cACI,iBAAA,CAEA,KAAA,CACA,MAAA,CAIA,UAFK,CAGL,WAHK,CAIL,kBAAA,CAEA,qBAAA,CAEA,yBAAA,CAEA,oBACI,UAAA\",\"sourcesContent\":[\"%no-select {\\r\\n  -webkit-touch-callout: none; /* iOS Safari */\\r\\n    -webkit-user-select: none; /* Safari */\\r\\n     -khtml-user-select: none; /* Konqueror HTML */\\r\\n       -moz-user-select: none; /* Old versions of Firefox */\\r\\n        -ms-user-select: none; /* Internet Explorer/Edge */\\r\\n            user-select: none; /* Non-prefixed version, currently\\r\\n                                  supported by Chrome, Edge, Opera and Firefox */\\r\\n}\\r\\n\\r\\ninput {\\r\\n    &:focus {\\r\\n        outline: none;\\r\\n    }\\r\\n}\\r\\n\\r\\n// Box-sizing model\\r\\nhtml {\\r\\n    -webkit-box-sizing: border-box;\\r\\n    -moz-box-sizing: border-box;\\r\\n    box-sizing: border-box;\\r\\n}\\r\\n\\r\\n*, *:before, *:after {\\r\\n    -webkit-box-sizing: inherit;\\r\\n    -moz-box-sizing: inherit;\\r\\n    box-sizing: inherit;\\r\\n}\\r\\n\\r\\nbody {\\r\\n    margin: 0;\\r\\n    padding: 0;\\r\\n    color: black;\\r\\n\\r\\n    width: 100%;\\r\\n    height: 100%;\\r\\n\\r\\n    overflow: hidden;\\r\\n\\r\\n    font-family: -apple-system, BlinkMacSystemFont, \\\"Segoe UI\\\", Roboto, Helvetica, Arial, sans-serif, \\\"Apple Color Emoji\\\", \\\"Segoe UI Emoji\\\", \\\"Segoe UI Symbol\\\";\\r\\n}\\r\\n\\r\\n#root {\\r\\n    position: absolute;\\r\\n    width: 100%;\\r\\n    height: 100%;\\r\\n\\r\\n    background: rgb(20, 20, 20);\\r\\n\\r\\n    gap: 4px;\\r\\n\\r\\n    display: grid;\\r\\n    place-items: center;\\r\\n}\\r\\n\\r\\n.pane {\\r\\n    background-color: white;\\r\\n    overflow: hidden;\\r\\n\\r\\n    border-radius: 4px;\\r\\n    position: relative;\\r\\n    width: 640px;\\r\\n    height: 480px;\\r\\n\\r\\n    .label {\\r\\n        position: absolute;\\r\\n        width: 100%;\\r\\n        background-color: rgba(221, 221, 221, 0.801);\\r\\n        padding: 8px;\\r\\n    }\\r\\n\\r\\n    .entity {\\r\\n        position: absolute;\\r\\n\\r\\n        top: 0;\\r\\n        left: 0;\\r\\n\\r\\n        $sz: 20px;\\r\\n\\r\\n        width: $sz;\\r\\n        height: $sz;\\r\\n        border-radius: $sz / 2;\\r\\n\\r\\n        background-color: black;\\r\\n\\r\\n        transform-box: content-box;\\r\\n\\r\\n        &.ghost {\\r\\n            opacity: 0.3;\\r\\n        }\\r\\n    }\\r\\n}\"],\"sourceRoot\":\"\"}]);\n// Exports\nexport default ___CSS_LOADER_EXPORT___;\n","var api = require(\"!../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\");\n            var content = require(\"!!../node_modules/css-loader/dist/cjs.js!../node_modules/sass-loader/dist/cjs.js!./style.scss\");\n\n            content = content.__esModule ? content.default : content;\n\n            if (typeof content === 'string') {\n              content = [[module.id, content, '']];\n            }\n\nvar options = {};\n\noptions.insert = \"head\";\noptions.singleton = false;\n\nvar update = api(content, options);\n\n\n\nmodule.exports = content.locals || {};","export function lerp(a: number, b: number, alpha: number): number {\r\n    return a + (b - a) * alpha;\r\n}","import \"./style.scss\"\r\nimport { cloneDeep } from \"lodash\";\r\nimport { lerp } from \"./math\";\r\n\r\nconst NUM_ENTITIES = 2;\r\n\r\nconst SERVER_TICK_DURATION = 1.0 / 20.0;\r\n\r\ntype Vec2 = { x: number, y: number }\r\ntype Entity = {\r\n    position: Vec2,\r\n    speed: number,\r\n    angle: number,\r\n    angularVelocity: number,\r\n    htmlElement: HTMLElement | null\r\n}\r\n\r\ntype Game = {\r\n    entities: Entity[]\r\n}\r\n\r\ntype Server = {\r\n    game: Game,\r\n\r\n    tick: number,\r\n    tickDuration: number,\r\n    tickAccumulator: number\r\n}\r\n\r\ntype ServerNetMessage = {\r\n    tick: number,\r\n    entityPositions: Vec2[]\r\n}\r\n\r\ntype ClientInFlightMessage = {\r\n    message: ServerNetMessage,\r\n\r\n    /**\r\n     * Time remaining before this message should be processed.\r\n     * (Due to simulated latency and jitter)\r\n     */\r\n    timeRemaining: number\r\n}\r\n\r\ntype Client = {\r\n    game: Game,\r\n    net: {\r\n        sim: {\r\n            /**\r\n             * Latency (network round-trip time) to server, in milliseconds\r\n             */\r\n            latency: number,\r\n\r\n            /**\r\n             * Jitter. Variance in delay between packets, in +- milliseconds\r\n             */\r\n            jitter: number \r\n\r\n            /**\r\n             * Packet loss, ranging from 0.0 (no packets lost) to 1.0 (all\r\n             * packets lost)\r\n             */\r\n            packetLoss: number,\r\n\r\n            /**\r\n             * List of in-flight messages waiting to be processed (due to\r\n             * simulated latency and jitter)\r\n             */\r\n            inFlightMessages: ClientInFlightMessage[],\r\n        },\r\n\r\n        /**\r\n         * Last received tick from the server\r\n         */\r\n        lastReceivedTick: number,\r\n\r\n        /**\r\n         * Network back buffer. \r\n         */\r\n        backBuffer: ServerNetMessage[],\r\n\r\n        /**\r\n         * How far in the past to render. A function of jitter and packet loss\r\n         * (variant network conditions). Measured in ticks.\r\n         */\r\n        interpolationDelay: number\r\n    }\r\n\r\n    /**\r\n     * Client clock. This should always be synchronized with the time of server\r\n     * ticks coming in from the network. If latency changes (average of jitter\r\n     * around clock != 0), the clock should be sped up or slowed down to\r\n     * resynchonize with the incoming server clock\r\n     */\r\n    tick: number,\r\n    tickAccumulator: number,\r\n\r\n    /** \r\n     * Client tick duration. Used to speed up and slow down the clock. In ideal\r\n     * conditions (no latency variation), this should match the server tick\r\n     * rate.\r\n     */\r\n    tickDuration: number,\r\n\r\n    prevNetState: ServerNetMessage | null,\r\n    nextNetState: ServerNetMessage | null\r\n}\r\n\r\ntype App = {\r\n    server: Server,\r\n    client: Client\r\n}\r\n\r\nconst app: App = {\r\n    server: {\r\n        tick: 0,\r\n        tickDuration: SERVER_TICK_DURATION,\r\n        tickAccumulator: 0.0,\r\n        game: { entities: [] }\r\n    },\r\n    client: {\r\n        game: { entities: [] },\r\n        net: {\r\n            sim: {\r\n                latency: 60.0,\r\n                jitter: 20.0,\r\n                packetLoss: 0.1,\r\n                inFlightMessages: []\r\n            },\r\n            lastReceivedTick: 0,\r\n            backBuffer: [],\r\n            interpolationDelay: 10.0\r\n        },\r\n\r\n        tick: 0,\r\n        tickDuration: SERVER_TICK_DURATION,\r\n        tickAccumulator: 0,\r\n\r\n        prevNetState: null,\r\n        nextNetState: null\r\n    }\r\n}\r\n\r\n// Expose app state to window (so it's accessible from the browser console)\r\ndeclare global {\r\n    interface Window { app: App }\r\n}\r\nwindow.app = app;\r\n\r\nfunction initAppState() {\r\n    // Initialise server and client entities\r\n    for (let i = 0; i < 2; ++i) {\r\n        for (let j = 0; j < NUM_ENTITIES; ++j) {\r\n            const entity: Entity = {\r\n                position: { x: 0.5, y: 0.5 },\r\n                speed: 0.0,\r\n                angle: 0.0,\r\n                angularVelocity: 0.0,\r\n                htmlElement: null\r\n            };\r\n\r\n            // Only initialise server entities properly.\r\n            // Client entities will be synced over the network.\r\n            if (i === 0) {\r\n                entity.position = {\r\n                    x: Math.random(),\r\n                    y: Math.random()\r\n                };\r\n\r\n                entity.speed = Math.random() * 0.2 + 0.1;\r\n                entity.angle = Math.random() * 2 * Math.PI;\r\n                // entity.angularVelocity = Math.random() * 0.01;\r\n\r\n                app.server.game.entities.push(entity);\r\n            } else {\r\n                app.client.game.entities.push(entity);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfunction domCreateElements() {\r\n    const elPane = document.createElement(\"div\");\r\n    elPane.className = \"pane\";\r\n\r\n    for (let i = 0; i < NUM_ENTITIES; ++i) {\r\n        for (let k = 0; k < 2; ++k) {\r\n\r\n            const elEntity = document.createElement(\"div\");\r\n            elEntity.className = \"entity\";\r\n            if (k === 0) elEntity.className += \" ghost\";\r\n\r\n            let color;\r\n            switch (i % 4) {\r\n                case 0:  color = \"red\"; break;\r\n                case 1:  color = \"green\"; break;\r\n                case 2:  color = \"blue\"; break;\r\n                case 3:  color = \"orange\"; break;\r\n                default: color = \"black\"; break;\r\n            }\r\n            elEntity.style.backgroundColor = color;\r\n\r\n            switch (k) {\r\n                case 0: {\r\n                    app.server.game.entities[i].htmlElement = elEntity;\r\n                } break;\r\n\r\n                case 1: {\r\n                    app.client.game.entities[i].htmlElement = elEntity;\r\n                } break;\r\n\r\n                // case 2: {\r\n\r\n                // } break;\r\n            }\r\n\r\n            elPane.append(elEntity);\r\n        }\r\n    }\r\n\r\n    document.getElementById(\"root\")!.append(elPane);\r\n}\r\n\r\nfunction serverTick(dt: number) {\r\n    const serverEntities = app.server.game.entities;\r\n\r\n    serverEntities.forEach(entity => {\r\n\r\n        if (Math.random() < 0.05) {\r\n            entity.angularVelocity = (2 * Math.random() - 1);\r\n        }\r\n\r\n        entity.angle += entity.angularVelocity * dt;\r\n\r\n        let velocity: Vec2 = {\r\n            x: Math.cos(entity.angle) * entity.speed,\r\n            y: Math.sin(entity.angle) * entity.speed\r\n        }\r\n\r\n        entity.position.x += velocity.x * dt;\r\n        entity.position.y += velocity.y * dt;\r\n\r\n        if (entity.position.x > 1.0) {\r\n            entity.position.x = 1.0;\r\n            velocity.x = -Math.abs(velocity.x);\r\n        } else if (entity.position.x < 0.0) {\r\n            entity.position.x = 0.0;\r\n            velocity.x = Math.abs(velocity.x);\r\n        }\r\n\r\n        if (entity.position.y > 1.0) {\r\n            entity.position.y = 1.0;\r\n            velocity.y = -Math.abs(velocity.y);\r\n        } else if (entity.position.y < 0.0) {\r\n            entity.position.y = 0.0;\r\n            velocity.y = Math.abs(velocity.y);\r\n        }\r\n\r\n        entity.angle = Math.atan2(velocity.y, velocity.x);\r\n        if (entity.angle < 0) {\r\n            entity.angle += 2 * Math.PI;\r\n        }\r\n    });\r\n\r\n    app.server.tick++;\r\n}\r\n\r\nfunction serverNetSend() {\r\n\r\n    const message: ServerNetMessage = {\r\n        tick: app.server.tick,\r\n        entityPositions: app.server.game.entities.map(e => e.position)\r\n    };\r\n\r\n    // Simulate sending data over the network, for each client\r\n    [app.client].forEach(client => {\r\n        // Simulate packet loss\r\n        const shouldDropPacket = Math.random() < client.net.sim.packetLoss;\r\n        if (shouldDropPacket) return;\r\n\r\n        const latency = client.net.sim.latency\r\n        const jitter  = (2 * Math.random() - 1) * client.net.sim.jitter;\r\n\r\n        const inFlightMessage: ClientInFlightMessage = {\r\n            message: cloneDeep(message),\r\n            timeRemaining: ((latency / 2) + jitter) / 1000.0\r\n        };\r\n\r\n        client.net.sim.inFlightMessages.push(inFlightMessage);\r\n    });\r\n}\r\n\r\nfunction onReceiveServerMessage(client: Client, message: ServerNetMessage) {\r\n\r\n    // Ignore out-of-order messages. Old messages are no longer relevant, because:\r\n    // 1. reliable messages (events) are redundantly included in future packets\r\n    // 2. unreliable messages (e.g. entity positions) are calculated against a\r\n    // diff of last acked gamestate for the client. Old positions aren't useful\r\n    // to the client, it can just lerp to the latest position\r\n    if (message.tick < client.net.lastReceivedTick) {\r\n        return;\r\n    }\r\n    client.net.lastReceivedTick = message.tick;\r\n\r\n    // Push the message to the back-buffer\r\n    client.net.backBuffer.push(cloneDeep(message));\r\n\r\n}\r\n\r\nlet lastFrameTime: number = 0;\r\n\r\nfunction frameStep(t: number) {\r\n    const rdt = (t - lastFrameTime) / 1000;\r\n    lastFrameTime = t;\r\n\r\n    // Server tick\r\n    app.server.tickAccumulator += rdt;\r\n\r\n    let ticked = false;\r\n    while (app.server.tickAccumulator > app.server.tickDuration) {\r\n        app.server.tickAccumulator -= app.server.tickDuration;\r\n        serverTick(app.server.tickDuration);\r\n        ticked = true;\r\n    }\r\n\r\n    if (ticked) {\r\n        serverNetSend();\r\n    }\r\n\r\n    // Client updates\r\n    [app.client].forEach(client => {\r\n        // Handle received data from the network\r\n        client.net.sim.inFlightMessages =\r\n        client.net.sim.inFlightMessages.filter(inFlightMessage => {\r\n            inFlightMessage.timeRemaining -= rdt;\r\n\r\n            if (inFlightMessage.timeRemaining <= 0.0) { \r\n                onReceiveServerMessage(client, inFlightMessage.message);\r\n                return false;\r\n            }\r\n\r\n            return true;\r\n        });\r\n\r\n        client.tickAccumulator += rdt;\r\n\r\n        while (client.tickAccumulator > client.tickDuration) {\r\n            client.tickAccumulator -= client.tickDuration;\r\n            client.tick++;\r\n        }\r\n\r\n        // Reset the client clock if it's fallen too far behind\r\n        if (client.net.backBuffer.length > 0) {\r\n            const mostRecent = client.net.backBuffer[client.net.backBuffer.length - 1];\r\n            if (mostRecent.tick < client.tick) {\r\n                client.tick = mostRecent.tick;\r\n                client.tickAccumulator = 0.0;\r\n            }\r\n        }\r\n\r\n        // Find the two network states that enclose our target time, determined\r\n        // by the interpolation delay\r\n        const targetSubTick = client.tick\r\n                                + (client.tickAccumulator / client.tickDuration)\r\n                                - client.net.interpolationDelay;\r\n\r\n        // Upper bound. The state that we will be interpolating towards\r\n        const nextNetStateIdx = client.net.backBuffer.findIndex(message =>\r\n            message.tick > targetSubTick\r\n        );\r\n\r\n        // Lower bound\r\n        client.prevNetState = nextNetStateIdx > 0 ? \r\n            client.net.backBuffer[nextNetStateIdx - 1] : null;\r\n\r\n        client.nextNetState = client.net.backBuffer[nextNetStateIdx];\r\n\r\n        // Remove old unneeded elements from the back buffer\r\n        client.net.backBuffer.splice(0, nextNetStateIdx - 1);\r\n        \r\n        // There's not a suitable next network state. This means we've stopped\r\n        // receiving data from the server for longer than the clock offset\r\n        // period. At this point, you could extrapolate from known data. Many\r\n        // games do this, and it looks like characters running into walls /\r\n        // around in circles etc. In this case, I'm going to do nothing but\r\n        // pause.\r\n        if (client.nextNetState === null) {\r\n            return;\r\n        }\r\n\r\n        // There's not a suitable older network state. This will only happen at\r\n        // the beginning of the session when we haven't accumulated enough data\r\n        // from the server yet. Do nothing.\r\n        if (client.prevNetState === null) {\r\n            return;\r\n        }\r\n\r\n        const t = targetSubTick;\r\n        const p = client.prevNetState!.tick;\r\n        const n = client.nextNetState!.tick;\r\n\r\n        const alpha = 1 - ((n - t) / (n - p));\r\n\r\n        client.game.entities.forEach((entity, idx) => {\r\n\r\n            const prevPosition = client.prevNetState!.entityPositions[idx];\r\n            const nextPosition = client.nextNetState!.entityPositions[idx];\r\n\r\n            const interpolatedPosition: Vec2 = {\r\n                x: lerp(prevPosition.x, nextPosition.x, alpha),\r\n                y: lerp(prevPosition.y, nextPosition.y, alpha)\r\n            };\r\n\r\n            entity.position = interpolatedPosition;\r\n        });\r\n    });\r\n\r\n    // Draw\r\n    [app.client.game, app.server.game].forEach(game => {\r\n        for (let i = 0; i < NUM_ENTITIES; ++i) {\r\n\r\n            let entityData = game.entities[i];\r\n            const elEntity = entityData.htmlElement;\r\n\r\n            if (elEntity !== null) {\r\n                const parentWidth = elEntity.parentElement!.clientWidth;\r\n                const parentHeight = elEntity.parentElement!.clientHeight;\r\n\r\n                elEntity.style.transform = `translateX(${entityData.position.x * (parentWidth - 20)}px)\r\n                                            translateY(${entityData.position.y * (parentHeight - 20)}px)`;\r\n            }\r\n        }\r\n    });\r\n}\r\n\r\nfunction main() {\r\n    initAppState();\r\n    domCreateElements();\r\n\r\n    function animationFrame(t: number) {\r\n        frameStep(t);\r\n        window.requestAnimationFrame(animationFrame);\r\n    }\r\n    requestAnimationFrame(animationFrame);\r\n}\r\n\r\nwindow.addEventListener(\"load\", main);"],"sourceRoot":""}