{"version":3,"sources":["webpack://fast_paced_networking_demo/./src/style.scss","webpack://fast_paced_networking_demo/./src/style.scss?75ba","webpack://fast_paced_networking_demo/./src/math.ts","webpack://fast_paced_networking_demo/./src/index.ts"],"names":["___CSS_LOADER_EXPORT___","push","module","id","api","content","__esModule","default","exports","locals","lerp","a","b","alpha","SERVER_TICK_DURATION","app","server","tick","tickDuration","tickAccumulator","game","entities","client","net","sim","latency","jitter","packetLoss","inFlightMessages","measured","jitterBackBuffer","lastReceivedTick","backBuffer","interpolationDelay","clockPaused","prevNetState","nextNetState","display","entityHtmlElements","serverTick","dt","forEach","entity","idx","Math","random","angularVelocity","angle","velocity","x","cos","speed","y","sin","position","abs","atan2","PI","updateEntityElementPosition","el","parentWidth","parentElement","clientWidth","parentHeight","clientHeight","style","transform","window","lastFrameTime","addEventListener","i","j","initAppState","elPane","document","createElement","className","htmlElements","k","elEntity","color","backgroundColor","append","getElementById","domCreateElements","requestAnimationFrame","animationFrame","t","rdt","message","ticked","entityPositions","map","e","inFlightMessage","cloneDeep","timeRemaining","filter","clientTime","clockDiffForPacket","length","splice","clockDiff","reduce","c","max","console","log","onReceiveServerMessage","targetSubTick","nextNetStateIdx","findIndex","p","n","prevPosition","nextPosition","interpolatedPosition","entityData","frameStep"],"mappings":"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","file":"main.f959ae52c4e9c538d73c.js","sourcesContent":["// Imports\nimport ___CSS_LOADER_API_IMPORT___ from \"../node_modules/css-loader/dist/runtime/api.js\";\nvar ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(true);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \"input:focus{outline:none}html{-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;-moz-box-sizing:inherit;box-sizing:inherit}body{margin:0;padding:0;color:#000;width:100%;height:100%;overflow:hidden;font-family:-apple-system,BlinkMacSystemFont,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\",\\\"Segoe UI Symbol\\\"}#root{position:absolute;width:100%;height:100%;background:#141414;gap:4px;display:grid;place-items:center}.pane{background-color:#fff;overflow:hidden;border-radius:4px;position:relative;width:640px;height:480px;box-shadow:0 0 10px 0 rgba(0,0,0,.3)}.pane .label{position:absolute;width:100%;background-color:rgba(221,221,221,.801);padding:8px}.pane .entity{position:absolute;top:0;left:0;width:20px;height:20px;border-radius:10px;background-color:#000;transform-box:content-box}.pane .entity.ghost{opacity:.3}\", \"\",{\"version\":3,\"sources\":[\"webpack://src/style.scss\"],\"names\":[],\"mappings\":\"AAWI,YACI,YAAA,CAKR,KACI,6BAAA,CACA,0BAAA,CACA,qBAAA,CAGJ,mBACI,0BAAA,CACA,uBAAA,CACA,kBAAA,CAGJ,KACI,QAAA,CACA,SAAA,CACA,UAAA,CAEA,UAAA,CACA,WAAA,CAEA,eAAA,CAEA,gJAAA,CAGJ,MACI,iBAAA,CACA,UAAA,CACA,WAAA,CAEA,kBAAA,CAEA,OAAA,CAEA,YAAA,CACA,kBAAA,CAGJ,MACI,qBAAA,CACA,eAAA,CAEA,iBAAA,CACA,iBAAA,CACA,WAAA,CACA,YAAA,CAEA,oCAAA,CAEA,aACI,iBAAA,CACA,UAAA,CACA,uCAAA,CACA,WAAA,CAGJ,cACI,iBAAA,CAEA,KAAA,CACA,MAAA,CAIA,UAFK,CAGL,WAHK,CAIL,kBAAA,CAEA,qBAAA,CAEA,yBAAA,CAEA,oBACI,UAAA\",\"sourcesContent\":[\"%no-select {\\r\\n  -webkit-touch-callout: none; /* iOS Safari */\\r\\n    -webkit-user-select: none; /* Safari */\\r\\n     -khtml-user-select: none; /* Konqueror HTML */\\r\\n       -moz-user-select: none; /* Old versions of Firefox */\\r\\n        -ms-user-select: none; /* Internet Explorer/Edge */\\r\\n            user-select: none; /* Non-prefixed version, currently\\r\\n                                  supported by Chrome, Edge, Opera and Firefox */\\r\\n}\\r\\n\\r\\ninput {\\r\\n    &:focus {\\r\\n        outline: none;\\r\\n    }\\r\\n}\\r\\n\\r\\n// Box-sizing model\\r\\nhtml {\\r\\n    -webkit-box-sizing: border-box;\\r\\n    -moz-box-sizing: border-box;\\r\\n    box-sizing: border-box;\\r\\n}\\r\\n\\r\\n*, *:before, *:after {\\r\\n    -webkit-box-sizing: inherit;\\r\\n    -moz-box-sizing: inherit;\\r\\n    box-sizing: inherit;\\r\\n}\\r\\n\\r\\nbody {\\r\\n    margin: 0;\\r\\n    padding: 0;\\r\\n    color: black;\\r\\n\\r\\n    width: 100%;\\r\\n    height: 100%;\\r\\n\\r\\n    overflow: hidden;\\r\\n\\r\\n    font-family: -apple-system, BlinkMacSystemFont, \\\"Segoe UI\\\", Roboto, Helvetica, Arial, sans-serif, \\\"Apple Color Emoji\\\", \\\"Segoe UI Emoji\\\", \\\"Segoe UI Symbol\\\";\\r\\n}\\r\\n\\r\\n#root {\\r\\n    position: absolute;\\r\\n    width: 100%;\\r\\n    height: 100%;\\r\\n\\r\\n    background: rgb(20, 20, 20);\\r\\n\\r\\n    gap: 4px;\\r\\n\\r\\n    display: grid;\\r\\n    place-items: center;\\r\\n}\\r\\n\\r\\n.pane {\\r\\n    background-color: white;\\r\\n    overflow: hidden;\\r\\n\\r\\n    border-radius: 4px;\\r\\n    position: relative;\\r\\n    width: 640px;\\r\\n    height: 480px;\\r\\n\\r\\n    box-shadow: 0 0 10px 0 rgba(0, 0, 0, 0.3);\\r\\n\\r\\n    .label {\\r\\n        position: absolute;\\r\\n        width: 100%;\\r\\n        background-color: rgba(221, 221, 221, 0.801);\\r\\n        padding: 8px;\\r\\n    }\\r\\n\\r\\n    .entity {\\r\\n        position: absolute;\\r\\n\\r\\n        top: 0;\\r\\n        left: 0;\\r\\n\\r\\n        $sz: 20px;\\r\\n\\r\\n        width: $sz;\\r\\n        height: $sz;\\r\\n        border-radius: $sz / 2;\\r\\n\\r\\n        background-color: black;\\r\\n\\r\\n        transform-box: content-box;\\r\\n\\r\\n        &.ghost {\\r\\n            opacity: 0.3;\\r\\n        }\\r\\n    }\\r\\n}\"],\"sourceRoot\":\"\"}]);\n// Exports\nexport default ___CSS_LOADER_EXPORT___;\n","var api = require(\"!../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\");\n            var content = require(\"!!../node_modules/css-loader/dist/cjs.js!../node_modules/sass-loader/dist/cjs.js!./style.scss\");\n\n            content = content.__esModule ? content.default : content;\n\n            if (typeof content === 'string') {\n              content = [[module.id, content, '']];\n            }\n\nvar options = {};\n\noptions.insert = \"head\";\noptions.singleton = false;\n\nvar update = api(content, options);\n\n\n\nmodule.exports = content.locals || {};","export function lerp(a: number, b: number, alpha: number): number {\r\n    return a + (b - a) * alpha;\r\n}\r\n\r\nexport function damp(a: number, b: number, lambda: number, dt: number) {\r\n    return lerp(a, b, 1 - Math.exp(lambda * -dt));\r\n}","import \"./style.scss\"\r\nimport { cloneDeep, update } from \"lodash\";\r\nimport { damp, lerp } from \"./math\";\r\n\r\nconst NUM_ENTITIES = 4;\r\n\r\nconst SERVER_TICK_DURATION = 1.0 / 90.0;\r\n\r\ntype Vec2 = { x: number, y: number }\r\ntype Entity = {\r\n    position: Vec2,\r\n    speed: number,\r\n    angle: number,\r\n    angularVelocity: number\r\n}\r\n\r\ntype Game = {\r\n    entities: Entity[]\r\n}\r\n\r\ntype Server = {\r\n    game: Game,\r\n\r\n    tick: number,\r\n    tickDuration: number,\r\n    tickAccumulator: number\r\n}\r\n\r\ntype ServerNetMessage = {\r\n    tick: number,\r\n    entityPositions: Vec2[]\r\n}\r\n\r\ntype ClientInFlightMessage = {\r\n    message: ServerNetMessage,\r\n\r\n    /**\r\n     * Time remaining before this message should be processed.\r\n     * (Due to simulated latency and jitter)\r\n     */\r\n    timeRemaining: number\r\n}\r\n\r\ntype EntityHtmlElementGroup = (HTMLElement | null)[];\r\n\r\ntype Client = {\r\n    game: Game,\r\n    net: {\r\n        /**\r\n         * Network conditions / data driving the simulation\r\n         */\r\n        sim: {\r\n            /**\r\n             * Latency (network round-trip time) to server, in milliseconds\r\n             */\r\n            latency: number,\r\n\r\n            /**\r\n             * Jitter. Variance in delay between packets, in +- milliseconds\r\n             */\r\n            jitter: number \r\n\r\n            /**\r\n             * Packet loss, ranging from 0.0 (no packets lost) to 1.0 (all\r\n             * packets lost)\r\n             */\r\n            packetLoss: number,\r\n\r\n            /**\r\n             * List of in-flight messages waiting to be processed (due to\r\n             * simulated latency and jitter)\r\n             */\r\n            inFlightMessages: ClientInFlightMessage[],\r\n        },\r\n\r\n        /**\r\n         * Network conditions as measured on the client-side\r\n         */\r\n        measured: {\r\n            latency:    number,\r\n            jitter:     number,\r\n            packetLoss: number,\r\n\r\n            jitterBackBuffer: number[],\r\n        }\r\n\r\n        /**\r\n         * Last received tick from the server\r\n         */\r\n        lastReceivedTick: number,\r\n\r\n        /**\r\n         * Network back buffer. \r\n         */\r\n        backBuffer: ServerNetMessage[],\r\n\r\n        /**\r\n         * How far in the past to render. A function of jitter and packet loss\r\n         * (variant network conditions). Measured in ticks.\r\n         */\r\n        interpolationDelay: number\r\n    }\r\n\r\n    /**\r\n     * Client clock. This should always be synchronized with the time of server\r\n     * ticks coming in from the network. If latency changes (average of jitter\r\n     * around clock != 0), the clock should be sped up or slowed down to\r\n     * resynchonize with the incoming server clock\r\n     */\r\n    tick: number,\r\n    tickAccumulator: number,\r\n    clockPaused: boolean,\r\n\r\n    /** \r\n     * Client tick duration. Used to speed up and slow down the clock. In ideal\r\n     * conditions (no latency variation), this should match the server tick\r\n     * rate.\r\n     */\r\n    tickDuration: number,\r\n\r\n    prevNetState: ServerNetMessage | null,\r\n    nextNetState: ServerNetMessage | null,\r\n\r\n    display: {\r\n        entityHtmlElements: EntityHtmlElementGroup[]\r\n    }\r\n}\r\n\r\ntype App = {\r\n    server: Server,\r\n    client: Client\r\n}\r\n\r\nconst app: App = {\r\n    server: {\r\n        tick: 0,\r\n        tickDuration: SERVER_TICK_DURATION,\r\n        tickAccumulator: 0.0,\r\n        game: { entities: [] }\r\n    },\r\n    client: {\r\n        game: { entities: [] },\r\n        net: {\r\n            sim: {\r\n                latency:    200.0,\r\n                jitter:     0.0,\r\n                packetLoss: 0.0,\r\n                inFlightMessages: []\r\n            },\r\n            measured: {\r\n                latency:    0.0,\r\n                jitter:     0.0,\r\n                packetLoss: 0.0,\r\n\r\n                jitterBackBuffer: [],\r\n            },\r\n            lastReceivedTick: 0,\r\n            backBuffer: [],\r\n            interpolationDelay: 2.0,\r\n        },\r\n\r\n        tick: 0,\r\n        tickDuration: SERVER_TICK_DURATION,\r\n        clockPaused: false,\r\n        tickAccumulator: 0,\r\n\r\n        prevNetState: null,\r\n        nextNetState: null,\r\n\r\n        display: {\r\n            entityHtmlElements: []\r\n        }\r\n    }\r\n}\r\n\r\n// Expose app state to window (so it's accessible from the browser console)\r\ndeclare global {\r\n    interface Window { app: App }\r\n}\r\nwindow.app = app;\r\n\r\nfunction initAppState() {\r\n    // Initialise server and client entities\r\n    for (let i = 0; i < 2; ++i) {\r\n        for (let j = 0; j < NUM_ENTITIES; ++j) {\r\n            const entity: Entity = {\r\n                position: { x: 0.5, y: 0.5 },\r\n                speed: 0.0,\r\n                angle: 0.0,\r\n                angularVelocity: 0.0,\r\n            };\r\n\r\n            // Only initialise server entities properly.\r\n            // Client entities will be synced over the network.\r\n            if (i === 0) {\r\n                entity.position = {\r\n                    x: Math.random(),\r\n                    y: Math.random()\r\n                };\r\n\r\n                entity.speed = Math.random() * 0.2 + 0.1;\r\n                entity.angle = Math.random() * 2 * Math.PI;\r\n                // entity.angularVelocity = Math.random() * 0.01;\r\n\r\n                app.server.game.entities.push(entity);\r\n            } else {\r\n                app.client.game.entities.push(entity);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfunction domCreateElements() {\r\n    const elPane = document.createElement(\"div\");\r\n    elPane.className = \"pane\";\r\n\r\n    for (let i = 0; i < NUM_ENTITIES; ++i) {\r\n\r\n        const htmlElements: EntityHtmlElementGroup = [];\r\n\r\n        for (let k = 0; k < 3; ++k) {\r\n\r\n            const elEntity = document.createElement(\"div\");\r\n            elEntity.className = \"entity\";\r\n            if (k !== 2) elEntity.className += \" ghost\";\r\n\r\n            let color;\r\n            switch (i % 4) {\r\n                case 0:  color = \"red\"; break;\r\n                case 1:  color = \"green\"; break;\r\n                case 2:  color = \"blue\"; break;\r\n                case 3:  color = \"orange\"; break;\r\n                default: color = \"black\"; break;\r\n            }\r\n            elEntity.style.backgroundColor = color;\r\n            htmlElements[k] = elEntity;\r\n\r\n            elPane.append(elEntity);\r\n        }\r\n\r\n        app.client.display.entityHtmlElements.push(htmlElements);\r\n    }\r\n\r\n    document.getElementById(\"root\")!.append(elPane);\r\n}\r\n\r\nfunction serverTick(dt: number) {\r\n    const serverEntities = app.server.game.entities;\r\n\r\n    serverEntities.forEach((entity, idx) => {\r\n\r\n        if (Math.random() < 0.05) {\r\n            entity.angularVelocity = (2 * Math.random() - 1);\r\n        }\r\n\r\n        entity.angle += entity.angularVelocity * dt;\r\n\r\n        let velocity: Vec2 = {\r\n            x: Math.cos(entity.angle) * entity.speed,\r\n            y: Math.sin(entity.angle) * entity.speed\r\n        }\r\n\r\n        entity.position.x += velocity.x * dt;\r\n        entity.position.y += velocity.y * dt;\r\n\r\n        if (entity.position.x > 1.0) {\r\n            entity.position.x = 1.0;\r\n            velocity.x = -Math.abs(velocity.x);\r\n        } else if (entity.position.x < 0.0) {\r\n            entity.position.x = 0.0;\r\n            velocity.x = Math.abs(velocity.x);\r\n        }\r\n\r\n        if (entity.position.y > 1.0) {\r\n            entity.position.y = 1.0;\r\n            velocity.y = -Math.abs(velocity.y);\r\n        } else if (entity.position.y < 0.0) {\r\n            entity.position.y = 0.0;\r\n            velocity.y = Math.abs(velocity.y);\r\n        }\r\n\r\n        entity.angle = Math.atan2(velocity.y, velocity.x);\r\n        if (entity.angle < 0) {\r\n            entity.angle += 2 * Math.PI;\r\n        }\r\n\r\n        // Update display\r\n        const elEntity = app.client.display.entityHtmlElements[idx][0]!;\r\n        updateEntityElementPosition(elEntity, entity.position.x, entity.position.y);\r\n    });\r\n\r\n    app.server.tick++;\r\n}\r\n\r\nfunction serverNetSend() {\r\n\r\n    const message: ServerNetMessage = {\r\n        tick: app.server.tick,\r\n        entityPositions: app.server.game.entities.map(e => e.position)\r\n    };\r\n\r\n    // Simulate sending data over the network, for each client\r\n    [app.client].forEach(client => {\r\n        // Simulate packet loss\r\n        const shouldDropPacket = Math.random() < client.net.sim.packetLoss;\r\n        if (shouldDropPacket) return;\r\n\r\n        const latency = client.net.sim.latency\r\n        const jitter  = (2 * Math.random() - 1) * client.net.sim.jitter;\r\n\r\n        const inFlightMessage: ClientInFlightMessage = {\r\n            message: cloneDeep(message),\r\n            timeRemaining: ((latency / 2) + jitter) / 1000.0\r\n        };\r\n\r\n        client.net.sim.inFlightMessages.push(inFlightMessage);\r\n    });\r\n}\r\n\r\nfunction updateEntityElementPosition(el: HTMLElement, x: number, y: number) {\r\n    const parentWidth = el.parentElement!.clientWidth;\r\n    const parentHeight = el.parentElement!.clientHeight;\r\n\r\n    el.style.transform = `translateX(${x * (parentWidth - 20)}px)\r\n                          translateY(${y * (parentHeight - 20)}px)`;\r\n}\r\n\r\nlet lastFrameTime: number = 0;\r\n\r\nfunction frameStep(t: number) {\r\n    const rdt = (t - lastFrameTime) / 1000;\r\n    lastFrameTime = t;\r\n\r\n    // Server tick\r\n    app.server.tickAccumulator += rdt;\r\n\r\n    let ticked = false;\r\n    while (app.server.tickAccumulator > app.server.tickDuration) {\r\n        app.server.tickAccumulator -= app.server.tickDuration;\r\n        serverTick(app.server.tickDuration);\r\n        ticked = true;\r\n    }\r\n\r\n    if (ticked) {\r\n        serverNetSend();\r\n    }\r\n\r\n    // Client updates\r\n    function onReceiveServerMessage(client: Client, message: ServerNetMessage) {\r\n\r\n        // Calculate the difference between our client clock (expected time of receipt) vs.\r\n        // actual time of receipt\r\n        const clientTime = client.tick + (client.tickAccumulator / client.tickDuration);\r\n        const clockDiffForPacket = message.tick - clientTime;\r\n\r\n        client.net.measured.jitterBackBuffer.push(clockDiffForPacket);\r\n\r\n        // Calculate the average delay over a period of time. The idea is to\r\n        // cancel out jitter to get an absolute difference between the server\r\n        // clock (as received) and our clock\r\n        const MAX_JITTER_ROLLING_AVERAGE = 5;\r\n\r\n        if (client.net.measured.jitterBackBuffer.length > MAX_JITTER_ROLLING_AVERAGE) {\r\n            client.net.measured.jitterBackBuffer.splice(0,\r\n                client.net.measured.jitterBackBuffer.length - MAX_JITTER_ROLLING_AVERAGE);\r\n        }\r\n\r\n        // The clock difference between packets as received and our client clock\r\n        const clockDiff = client.net.measured.jitterBackBuffer.reduce((a, c) => a + c, 0.0) /\r\n            client.net.measured.jitterBackBuffer.length;\r\n\r\n        // Appropriately speed up or slow down our simulation to bring ourselves\r\n        // back in line with the server clock\r\n        client.tickDuration = Math.max(\r\n            SERVER_TICK_DURATION * 0.9,\r\n            SERVER_TICK_DURATION - (0.01 * (clockDiff * SERVER_TICK_DURATION))\r\n        );\r\n\r\n        // console.log(\"Clock multiplier\", client.tickDuration / SERVER_TICK_DURATION);\r\n\r\n        // const jitterMax =\r\n        //     client.net.measured.jitterBackBuffer.reduce((a, c) => Math.max(Math.abs(c - jitterAv), a), 0.0);\r\n\r\n        // Ignore out-of-order messages. Old messages are no longer relevant, because:\r\n        // 1. reliable messages (events) are redundantly included in future packets\r\n        // 2. unreliable messages (e.g. entity positions) are calculated against a\r\n        // diff of last acked gamestate for the client. Old positions aren't useful\r\n        // to the client, it can just lerp to the latest position\r\n\r\n        if (message.tick < client.net.lastReceivedTick) {\r\n            return;\r\n        }\r\n        client.net.lastReceivedTick = message.tick;\r\n\r\n        if (client.clockPaused) {\r\n            console.log(\"Clock resumed\", client.tick, client.tickAccumulator, message.tick);\r\n            client.clockPaused = false;\r\n            client.tick = message.tick;\r\n            client.tickAccumulator = 0.0;\r\n        }\r\n\r\n        // Push the message to the back-buffer\r\n        client.net.backBuffer.push(cloneDeep(message));\r\n\r\n        // Update display for received entities\r\n        message.entityPositions.forEach((entity, idx) => {\r\n            const elEntity = client.display.entityHtmlElements[idx][1]!;\r\n            updateEntityElementPosition(elEntity, entity.x, entity.y);\r\n        });\r\n    }\r\n\r\n    [app.client].forEach(client => {\r\n\r\n        // Handle received data from the network\r\n        client.net.sim.inFlightMessages =\r\n        client.net.sim.inFlightMessages.filter(inFlightMessage => {\r\n            inFlightMessage.timeRemaining -= rdt;\r\n\r\n            if (inFlightMessage.timeRemaining <= 0.0) { \r\n                onReceiveServerMessage(client, inFlightMessage.message);\r\n                return false;\r\n            }\r\n\r\n            return true;\r\n        });\r\n\r\n        // Update client clock\r\n        {\r\n            if (!client.clockPaused) {\r\n                client.tickAccumulator += rdt;\r\n\r\n                while (client.tickAccumulator > client.tickDuration) {\r\n                    client.tickAccumulator -= client.tickDuration;\r\n                    client.tick++;\r\n                }\r\n            }\r\n\r\n            // TODO(WF): Temp hack, fix\r\n            // Reset the client clock if it's fallen too far behind\r\n            // if (client.net.backBuffer.length > 0) {\r\n            //     const mostRecent = client.net.backBuffer[client.net.backBuffer.length - 1];\r\n            //     if (mostRecent.tick <= client.tick) {\r\n            //         client.tick = mostRecent.tick;\r\n            //         client.tickAccumulator = 0.0;\r\n            //     }\r\n            // }\r\n        }\r\n\r\n        // client.net.clockDelay = damp(client.net.clockDelay, client.net.targetClockDelay, 4, rdt);\r\n\r\n        // The time in ticks which we want to draw\r\n        const targetSubTick = client.tick\r\n                                + (client.tickAccumulator / client.tickDuration)\r\n                                - client.net.interpolationDelay;\r\n\r\n        // Client clock is too far ahead (server is stalling, latency increased, etc.)\r\n        // Pause the client clock until we receive some net data\r\n        if (client.net.backBuffer.length === 0 ||\r\n            targetSubTick > client.net.backBuffer[client.net.backBuffer.length - 1].tick) {\r\n\r\n            if (!app.client.clockPaused) {\r\n                console.log(\"Clock paused\");\r\n                app.client.clockPaused = true;\r\n            }\r\n\r\n            return;\r\n        }\r\n\r\n        // Upper bound. The state that we will be interpolating towards\r\n        const nextNetStateIdx = client.net.backBuffer.findIndex(message =>\r\n            message.tick > targetSubTick\r\n        );\r\n\r\n        // Lower bound\r\n        client.prevNetState = nextNetStateIdx > 0 ? \r\n            client.net.backBuffer[nextNetStateIdx - 1] : null;\r\n\r\n        client.nextNetState = client.net.backBuffer[nextNetStateIdx] ?? null;\r\n\r\n        // Remove old unneeded elements from the back buffer\r\n        client.net.backBuffer.splice(0, nextNetStateIdx - 1);\r\n        \r\n        // There's not a suitable next network state. This means we've stopped\r\n        // receiving data from the server for longer than the clock offset\r\n        // period. At this point, you could extrapolate from known data. Many\r\n        // games do this, and it looks like characters running into walls /\r\n        // around in circles etc. In this case, I'm going to do nothing but\r\n        // pause.\r\n        if (client.nextNetState === null) {\r\n            return;\r\n        }\r\n\r\n        // There's not a suitable older network state. This will only happen at\r\n        // the beginning of the session when we haven't accumulated enough data\r\n        // from the server yet. Do nothing.\r\n        if (client.prevNetState === null) {\r\n            return;\r\n        }\r\n\r\n        const t = targetSubTick;\r\n        const p = client.prevNetState!.tick;\r\n        const n = client.nextNetState!.tick;\r\n\r\n        const alpha = 1 - ((n - t) / (n - p));\r\n\r\n        client.game.entities.forEach((entity, idx) => {\r\n\r\n            const prevPosition = client.prevNetState!.entityPositions[idx];\r\n            const nextPosition = client.nextNetState!.entityPositions[idx];\r\n\r\n            const interpolatedPosition: Vec2 = {\r\n                x: lerp(prevPosition.x, nextPosition.x, alpha),\r\n                y: lerp(prevPosition.y, nextPosition.y, alpha)\r\n            };\r\n\r\n            entity.position = interpolatedPosition;\r\n        });\r\n    });\r\n\r\n    // Draw client entities\r\n    for (let i = 0; i < NUM_ENTITIES; ++i) {\r\n\r\n        let entityData = app.client.game.entities[i];\r\n        const elEntity = app.client.display.entityHtmlElements[i][2]!;\r\n\r\n        updateEntityElementPosition(elEntity, entityData.position.x, entityData.position.y);\r\n    }\r\n}\r\n\r\nfunction main() {\r\n    initAppState();\r\n    domCreateElements();\r\n\r\n    function animationFrame(t: number) {\r\n        frameStep(t);\r\n        window.requestAnimationFrame(animationFrame);\r\n    }\r\n    requestAnimationFrame(animationFrame);\r\n}\r\n\r\nwindow.addEventListener(\"load\", main);"],"sourceRoot":""}